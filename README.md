## PyTor
A Bit Torrent client implemented in python.


### Usage
- Install the required dependencies `pip install -r requirements.txt`.
- Run the main `python main.py /path/file.torrent`.

### Overview of the code
Here's a basic idea of the code:

#### Torrent Class

The `Torrent` class represents a BitTorrent metadata file parser. It is responsible for loading and parsing a torrent file and extracting relevant information such as the file names, total length, piece length, pieces, info hash, peer ID, and the list of trackers.

#### Attributes

- `torrent_file`: (dict) Stores the contents of the torrent file in a dictionary format after parsing.
- `total_length`: (int) Total length of all files in the torrent. It is calculated by summing the lengths of all files in the case of a multi-file torrent or represents the length of the single file in a single-file torrent.
- `piece_length`: (int) Length of each piece in the torrent, specified in bytes.
- `pieces`: (int) Number of pieces in the torrent, represented as a string of concatenated 20-byte SHA-1 hash values.
- `info_hash`: (str) Hash value of the 'info' dictionary in the torrent. It is calculated by taking the SHA-1 hash of the 'info' dictionary after encoding it in Bencode format.
- `peer_id`: (str) Unique identifier for the client (peer) in the BitTorrent network. It is generated by hashing the current timestamp to create a 20-byte unique ID.
- `announce_list`: (list) List of trackers for the torrent. It can contain multiple tiers of trackers.
- `file_names`: (list) List of dictionaries containing the file names and their respective lengths in the torrent.
- `number_of_pieces`: (int) Number of pieces calculated based on the total length and piece length.

#### Methods

#### `load_from_path(self, path)`

Load and parse a torrent file from the given path.

**Arguments:**

- `path` (str): Path to the torrent file.

**Returns:**

- `Torrent`: The Torrent object itself.

**Raises:**

- `AssertionError`: If the total length or file names are not valid.

#### `init_files(self)`

Initialize the file names and calculate the total length of the torrent.

This function handles both single-file and multi-file torrents. For single-file torrents, the root name is used as the file name. For multi-file torrents, the file names are constructed using the 'name' and 'path' fields. For both cases, the total length of the torrent is calculated by summing the lengths of all files.

**Returns:**

- None

#### `get_trackers(self)`

Retrieve the list of trackers from the torrent file.

If the 'announce-list' field is present, return its value. Otherwise, return a list containing the 'announce' field value.

**Returns:**

- list: List of trackers.

#### `generate_peer_id(self)`

Generate a unique peer ID for the client.

The peer ID is calculated by hashing the current timestamp.

**Returns:**

- str: Generated peer ID.


#### Message Class

The `Message` class is a base class for BitTorrent messages. It defines two methods: `to_bytes()` and `from_bytes()`. Subclasses of the `Message` class should implement these methods to convert the message object to bytes and create a message object from bytes, respectively.

#### Methods

#### `to_bytes(self)`

Converts the message object to bytes.

Returns:
- `bytes`: The message object converted to bytes.

#### `from_bytes(cls, payload)`

Creates a message object from bytes.

Arguments:
- `payload` (bytes): The bytes representing the message.

Returns:
- `Message`: The created message object.

#### UdpTrackerConnection Class

The `UdpTrackerConnection` class represents a connection message for the UDP tracker. It inherits from the `Message` class.

#### Methods

#### `to_bytes(self)`

Converts the connection message to bytes.

Returns:
- `bytes`: The connection message converted to bytes.

#### `from_bytes(self, payload)`

Creates a connection message object from bytes.

Arguments:
- `payload` (bytes): The bytes representing the connection message.

#### UdpTrackerAnnounce Class

The `UdpTrackerAnnounce` class represents an announce message for the UDP tracker. It inherits from the `Message` class.

#### Methods

#### `to_bytes(self)`

Converts the announce message to bytes.

Returns:
- `bytes`: The announce message converted to bytes.

#### `from_bytes(self, payload)`

Creates an announce message object from bytes.

Arguments:
- `payload` (bytes): The bytes representing the announce message.

#### UdpTrackerAnnounceOutput Class

The `UdpTrackerAnnounceOutput` class represents the output of the announce message for the UDP tracker.

#### Attributes

- `action`: Action field of the announce output.
- `trans_id`: Transaction ID field of the announce output.
- `interval`: Interval field of the announce output.
- `leechers`: Number of leechers field of the announce output.
- `seeders`: Number of seeders field of the announce output.
- `socket_addresses`: List to store socket addresses of peers.

#### Methods

#### `from_bytes(self, payload)`

Creates an announce output object from bytes.

Arguments:
- `payload` (bytes): The bytes representing the announce output.

#### Handshake Class

The `Handshake` class represents the handshake message used in the BitTorrent protocol. It inherits from the `Message` class.

#### Attributes

- `payload_length`: Length of the handshake message payload.
- `total_length`: Total length of the handshake message.

#### Methods

#### `to_bytes(self)`

Converts the handshake message to bytes.

Returns:
- `bytes`: The handshake message converted to bytes.

#### `from_bytes(cls, payload)`

Creates a handshake message object from bytes.

Arguments:
- `payload` (bytes): The bytes representing the handshake message.

#### Regular Message Classes

The following classes represent regular messages used in the BitTorrent protocol:

- `KeepAlive`: Represents the keep-alive message.
- `Choke`: Represents the choke message.
- `UnChoke`: Represents the unchoke message.
- `Interested`: Represents the interested message.
- `NotInterested`: Represents the not interested message.
- `Have`: Represents the have message.
- `Bitfield`: Represents the bitfield message.
- `Request`: Represents the request message.
- `Piece`: Represents the piece message.
- `Cancel`: Represents the cancel message.

Each of these classes inherits from the `Message` class and provides methods `to_bytes()` and `from_bytes()`.


#### Piece Class

The `Piece` class represents a piece in the BitTorrent protocol. It contains methods for managing the piece's blocks, updating block status, setting and retrieving block data, finding empty blocks, checking if all blocks are full, and validating the piece's data.

#### Attributes

- `piece_index` (int): The index of the piece.
- `piece_size` (int): The size of the piece.
- `piece_hash` (str): The expected hash of the piece's data.
- `is_full` (bool): Indicates if the piece is fully downloaded.
- `files` (list): List of files associated with the piece.
- `raw_data` (bytes): The raw data of the piece.
- `number_of_blocks` (int): The number of blocks in the piece.
- `blocks` (list[Block]): List of blocks in the piece.

#### Methods

#### `__init__(self, piece_index: int, piece_size: int, piece_hash: str)`

Initializes a `Piece` object with the specified piece index, size, and hash.

Arguments:
- `piece_index` (int): The index of the piece.
- `piece_size` (int): The size of the piece.
- `piece_hash` (str): The expected hash of the piece's data.

#### `update_block_status(self)`

Updates the status of the blocks in the piece. If a block is pending for too long, it sets the block to free.

#### `set_block(self, offset, data)`

Sets the data for a specific block within the piece based on the offset.

Arguments:
- `offset` (int): The offset within the piece where the block starts.
- `data` (bytes): The data to set for the block.

#### `get_block(self, block_offset, block_length)`

Retrieves a specific block of data from the piece based on the block's offset and length.

Arguments:
- `block_offset` (int): The offset of the block within the piece.
- `block_length` (int): The length of the block.

Returns:
- `bytes`: The retrieved block of data.

#### `get_empty_block(self)`

Finds and returns an empty block within the piece. If all blocks are full or the piece is already full, it returns None.

Returns:
- `tuple` or `None`: A tuple containing the piece index, block offset, and block size of the empty block, or None if no empty block is found.

#### `are_all_blocks_full(self)`

Checks if all blocks of the piece are full.

Returns:
- `bool`: True if all blocks are full, False otherwise.

#### `set_to_full(self)`

Sets the piece to full if all blocks are filled and the data passes the validation check. Writes the completed piece to disk and publishes a message indicating the completion.

Returns:
- `bool`: True if the piece is successfully set to full, False otherwise.

#### `_init_blocks(self)`

Initializes the blocks of the piece based on the number of blocks required.

#### `_write_piece_on_disk(self)`

Writes the completed piece's data to the corresponding files on disk.

#### `_merge_blocks(self)`

Merges the data of all blocks into a single byte string.

#### `_valid_blocks(self, piece_raw_data)`

Validates the piece's raw data by comparing its hash with the expected hash.


#### PiecesManager Class

The `PiecesManager` class manages the pieces in the BitTorrent protocol. It keeps track of the completion status of each piece, updates the bitfield, receives blocks of data for pieces, retrieves specific blocks, and checks if all pieces have been completed.

#### Attributes

- `torrent`: The torrent object.
- `number_of_pieces` (int): The number of pieces in the torrent.
- `bitfield`: The bitfield indicating the completion status of the pieces.
- `pieces` (list): The list of `Piece` objects representing the pieces.
- `files` (list): The list of file objects with their metadata and piece assignments.
- `complete_pieces` (int): The number of completed pieces.

#### Methods

#### `__init__(self, torrent)`

Initializes a `PiecesManager` object with the specified torrent.

Arguments:
- `torrent`: The torrent object.

#### `update_bitfield(self, piece_index)`

Updates the bitfield to indicate the completion of a piece.

Arguments:
- `piece_index` (int): The index of the completed piece.

#### `receive_block_piece(self, piece)`

Receives a block of data for a piece and updates the piece's blocks accordingly. If all blocks of a piece are filled, sets the piece to full.

Arguments:
- `piece` (tuple): A tuple containing the piece index, piece offset, and piece data.

#### `get_block(self, piece_index, block_offset, block_length)`

Retrieves a specific block of data from a piece.

Arguments:
- `piece_index` (int): The index of the piece.
- `block_offset` (int): The offset of the block within the piece.
- `block_length` (int): The length of the block.

Returns:
- `bytes`: The retrieved block of data.

#### `all_pieces_completed(self)`

Checks if all pieces have been completed.

Returns:
- `bool`: True if all pieces are completed, False otherwise.

#### `_generate_pieces(self)`

Generates the pieces based on the torrent information.

Returns:
- `list`: A list of `Piece` objects representing the pieces of the torrent.

#### `_load_files(self)`

Loads the files of the torrent and assigns them to the corresponding pieces.

Returns:
- `list`: A list of file objects with their metadata and piece assignments.


#### Peer Class

The `Peer` class represents a peer in the BitTorrent protocol. It handles communication with peers, manages the state of the peer, and performs various actions such as connecting, sending messages, handling messages, and checking the status of the peer.

#### Attributes

- `last_call`: The timestamp of the last communication with the peer.
- `has_handshaked`: A flag indicating whether the peer has completed the handshake.
- `healthy`: A flag indicating the health status of the peer.
- `read_buffer`: A buffer to store received data from the peer.
- `socket`: The socket object for communication with the peer.
- `ip`: The IP address of the peer.
- `port`: The port number of the peer.
- `number_of_pieces`: The total number of pieces in the torrent.
- `bit_field`: The bit field representing the pieces the peer has.
- `state`: The state of the peer, including choking and interest flags.

#### Methods

#### `__init__(self, number_of_pieces, ip, port=6881)`

Initializes a `Peer` object with the specified attributes.

Arguments:
- `number_of_pieces`: The total number of pieces in the torrent.
- `ip`: The IP address of the peer.
- `port` (optional): The port number of the peer. Default is 6881.

#### `connect(self)`

Attempts to create a socket connection with the peer.

Returns:
- `bool`: True if the connection is successfully established, False otherwise.

#### `send_to_peer(self, msg)`

Sends a message to the peer over the socket connection.

Arguments:
- `msg`: The message to send to the peer.

#### `is_eligible(self)`

Checks if the peer is eligible for communication based on the time elapsed since the last call.

Returns:
- `bool`: True if eligible, False otherwise.

#### `has_piece(self, index)`

Checks if the peer has the piece at the given index in its bit field.

Arguments:
- `index`: The index of the piece to check.

Returns:
- `bool`: True if the peer has the piece, False otherwise.

#### `am_choking(self)`

Checks if the peer is choking (not sending data to the client).

Returns:
- `bool`: True if the peer is choking, False otherwise.

#### `am_unchoking(self)`

Checks if the peer is unchoking (sending data to the client).

Returns:
- `bool`: True if the peer is unchoking, False otherwise.

#### `is_choking(self)`

Checks if the peer is being choked by the client (client not sending requests).

Returns:
- `bool`: True if the peer is being choked, False otherwise.

#### `is_unchoked(self)`

Checks if the peer is unchoked by the client (client sending requests).

Returns:
- `bool`: True if the peer is unchoked, False otherwise.

#### `is_interested(self)`

Checks if the peer is interested in the client's pieces.

Returns:
- `bool`: True if the peer is interested, False otherwise.

#### `am_interested(self)`

Checks if the client is interested in the peer's pieces.

Returns:
- `bool`: True if the client is interested, False otherwise.

#### `handle_choke(self)`

Handles the choke message from the peer.

#### `handle_unchoke(self)`

Handles the unchoke message from the peer.

#### `handle_interested(self)`

Handles the interested message from the peer.

#### `handle_not_interested(self)`

Handles the not interested message from the peer.

#### `handle_have(self, have)`

Handles the have message from the peer.

Arguments:
- `have`: The have message object.

#### `handle_bitfield(self, bitfield)`

Handles the bitfield message from the peer.

Arguments:
- `bitfield`: The bitfield message object.

#### `handle_request(self, request)`

Handles the request message from the peer.

Arguments:
- `request`: The request message object.

#### `handle_piece(self, message)`

Handles the piece message from the peer.

Arguments:
- `message`: The piece message object.

#### `handle_cancel(self)`

Handles the cancel message from the peer.

#### `handle_port_request(self)`

Handles the port request message from the peer.

#### `_handle_handshake(self)`

Handles the handshake message from the peer.

Returns:
- `bool`: True if the handshake message handling is successful, False otherwise.

#### `_handle_keep_alive(self)`

Handles the keep-alive message from the peer.

Returns:
- `bool`: True if the keep-alive message handling is successful, False otherwise.

#### `get_messages(self)`

Continuously loops while there is data in the read buffer and the peer is healthy, and processes the received messages from the peer.

Returns:
- None


#### PeersManager Class

The `PeersManager` class manages the peers in the BitTorrent network. It handles the addition and removal of peers, performs the handshake with peers, and processes the messages received from peers.

#### Attributes

- `peers`: A list to store the peer objects.
- `torrent`: The torrent object.
- `pieces_manager`: The PiecesManager object.
- `rarest_pieces`: The RarestPieces object.
- `pieces_by_peer`: A list to store pieces by peer.
- `is_active`: A flag to control the thread execution.

#### Methods

#### `__init__(self, torrent, pieces_manager)`

Initializes a `PeersManager` object with the specified torrent and pieces_manager.

Arguments:
- `torrent`: The torrent object.
- `pieces_manager`: The PiecesManager object.

#### `peer_requests_piece(self, request=None, peer=None)`

Processes a piece request from a peer.

Arguments:
- `request`: The piece request.
- `peer`: The peer object that sent the request.

#### `peers_bitfield(self, bitfield=None)`

Updates the peer's bitfield in the `pieces_by_peer` list.

Arguments:
- `bitfield`: The bitfield of a peer.

#### `get_random_peer_having_piece(self, index)`

Gets a random peer that has a specific piece.

Arguments:
- `index`: The index of the desired piece.

Returns:
- A random peer object that has the specified piece, or None if no such peer is found.

#### `has_unchoked_peers(self)`

Checks if there are any unchoked peers.

Returns:
- `bool`: True if there are unchoked peers, False otherwise.

#### `unchoked_peers_count(self)`

Gets the count of unchoked peers.

Returns:
- `int`: The count of unchoked peers.

#### `_read_from_socket(sock)`

Reads data from a socket.

Arguments:
- `sock`: The socket to read from.

Returns:
- The read data.

#### `run(self)`

Continuously loops while the `is_active` flag is True. It reads data from the sockets of the peers and processes the received messages.

#### `_do_handshake(self, peer)`

Performs the handshake with a peer.

Arguments:
- `peer`: The peer object to perform the handshake with.

Returns:
- `bool`: True if the handshake is successful, False otherwise.

#### `add_peers(self, peers)`

Adds new peers to the `peers` list.

Arguments:
- `peers`: A list of peer objects to add.

#### `remove_peer(self, peer)`

Removes a peer from the `peers` list.

Arguments:
- `peer`: The peer object to remove.

#### `get_peer_by_socket(self, socket)`

Gets a peer object based on the associated socket.

Arguments:
- `socket`: The socket associated with the peer.

Returns:
- The peer object.

Raises:
- `Exception`: If the peer is not present in the `peers` list.

#### `_process_new_message(self, new_message: Message, peer: Peer)`

Processes a new message received from a peer.

Arguments:
- `new_message`: The new message object.
- `peer`: The peer object that sent the message.


#### SockAddr Class

The `SockAddr` class represents a socket address with an IP address and port.

#### Attributes

- `ip`: The IP address of the socket.
- `port`: The port number of the socket.
- `allowed`: A flag to indicate if this socket is allowed.

#### Methods

#### `__init__(self, ip, port, allowed=True)`

Initializes a `SockAddr` object with the specified IP address, port, and allowed flag.

Arguments:
- `ip`: The IP address of the socket.
- `port`: The port number of the socket.
- `allowed`: A flag to indicate if this socket is allowed. (default: True)

#### `__hash__(self)`

Returns a unique hash for the `SockAddr` object based on its IP address and port.

#### Tracker Class

The `Tracker` class handles tracker communication and peer connections.

#### Attributes

- `torrent`: The Torrent object containing information about the torrent file.
- `threads_list`: A list to store threads for peer connections (not used in the provided code).
- `connected_peers`: A dictionary to store connected peers with their hash as the key.
- `dict_sock_addr`: A dictionary to store socket addresses of potential peers.

#### Methods

#### `__init__(self, torrent)`

Initializes a `Tracker` object with the specified torrent.

Arguments:
- `torrent`: The Torrent object containing information about the torrent file.

#### `get_peers_from_trackers(self)`

Gets peers from all trackers associated with the torrent.

Returns:
- A dictionary of connected peers with their hash as the key.

#### `try_peer_connect(self)`

Tries to establish connections to the discovered peers.

#### `http_scraper(self, torrent, tracker)`

Scrapes peers from an HTTP tracker.

Arguments:
- `torrent`: The Torrent object.
- `tracker`: The URL of the HTTP tracker.

#### `udp_scrapper(self, announce)`

Scrapes peers from a UDP tracker.

Arguments:
- `announce`: The URL of the UDP tracker.

#### `send_message(self, conn, sock, tracker_message)`

Sends a message to the tracker and receives the response.

Arguments:
- `conn`: The connection information for the tracker.
- `sock`: The UDP socket for communication.
- `tracker_message`: The message to send to the tracker.

Returns:
- The response received from the tracker.


#### Run Class

The `Run` class is responsible for managing the downloading process.

#### Attributes

- `percentage_completed`: The percentage of completion of the download.
- `last_log_line`: The last log line displayed during the download process.
- `torrent`: The Torrent object containing information about the torrent file.
- `tracker`: The Tracker object for the torrent.
- `pieces_manager`: The PiecesManager object for managing pieces.
- `peers_manager`: The PeersManager object for managing peers.

#### Methods

#### `__init__(self)`

Initializes a `Run` object. Loads the torrent file, creates the tracker, pieces manager, and peers manager objects, and starts the managers.

#### `start(self)`

Starts the downloading process. Gets peers from the tracker, adds them to the peers manager, and continues downloading until all pieces are completed.

#### `display_progression(self)`

Displays the download progression. Calculates the percentage of completion and the number of connected and completed pieces, and prints the progress.

#### `_exit_threads(self)`

Exits the download threads. Sets the peers manager's `is_active` flag to False and exits the program.

#### Main

The `Main` class is the entry point of the program.

#### Methods

#### `__main__`

The main method of the program. Sets the logging level to DEBUG, creates a `Run` object, and starts the downloading process.


### Credits
- [Mary Rose Cook](https://twitter.com/maryrosecook), for inspiring me to take on something like this.
- [Kristen Widman](http://www.kristenwidman.com/blog/), for the wonderful [guide](http://www.kristenwidman.com/blog/33/how-to-write-a-bittorrent-client-part-1/), which was an enourmous help.
- The [Offical spec](https://notes.kishorekaranam.com/Bit%20Torrent%20Spec) of Bit Torrent.


### License
[MIT](https://github.com/itsknk/PyTor/blob/master/LICENSE)
